package it.unive.golisa.golang.util;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import it.unive.golisa.golang.api.signature.ConstGoLangApiSignature;
import it.unive.golisa.golang.api.signature.FuncGoLangApiSignature;
import it.unive.golisa.golang.api.signature.MethodGoLangApiSignature;
import it.unive.golisa.golang.api.signature.TypeGoLangApiSignature;
import it.unive.golisa.golang.api.signature.VarGoLangApiSignature;

/**
 * Auto-generated by GoLiSA build
 */
public class Go1_8 {
	private final Map<String, Set<ConstGoLangApiSignature>> mapConst;
	private final Map<String, Set<FuncGoLangApiSignature>> mapFunc;
	private final Map<String, Set<MethodGoLangApiSignature>> mapMethod;
	private final Map<String, Set<TypeGoLangApiSignature>> mapType;
	private final Map<String, Set<VarGoLangApiSignature>> mapVar;
	private final Set<String> pkgs;

	public Go1_8() {
		pkgs = new HashSet<>();
		mapConst = new HashMap<String, Set<ConstGoLangApiSignature>>();
		mapFunc = new HashMap<String, Set<FuncGoLangApiSignature>>();
		mapMethod = new HashMap<String, Set<MethodGoLangApiSignature>>();
		mapType = new HashMap<String, Set<TypeGoLangApiSignature>>();
		mapVar = new HashMap<String, Set<VarGoLangApiSignature>>();

		build();
	}

	public Set<String> getPackages() {
		return pkgs;
	}

	public Map<String, Set<ConstGoLangApiSignature>> getMapConst() {
		return mapConst;
	}

	public Map<String, Set<FuncGoLangApiSignature>> getMapFunc() {
		return mapFunc;
	}

	public Map<String, Set<MethodGoLangApiSignature>> getMapMethod() {
		return mapMethod;
	}

	public Map<String, Set<TypeGoLangApiSignature>> getMapType() {
		return mapType;
	}

	public Map<String, Set<VarGoLangApiSignature>> getMapVar() {
		return mapVar;
	}

	private void build() {
		build0();
	}

	private void build0() {
		pkgs.add("crypto/tls");
		mapConst.putIfAbsent("crypto/tls", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("crypto/tls", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("crypto/tls", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("crypto/tls", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("crypto/tls", new HashSet<VarGoLangApiSignature>());

		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "PSSWithSHA512", null, "SignatureScheme"));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "PSSWithSHA512", " 2054", null));
		mapConst.get("crypto/tls").add(
				new ConstGoLangApiSignature("crypto/tls", "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305", null, "uint16"));
		mapType.get("crypto/tls").add(
				new TypeGoLangApiSignature("crypto/tls", "CertificateRequestInfo struct, AcceptableCAs [][]uint8"));
		mapType.get("crypto/tls").add(new TypeGoLangApiSignature("crypto/tls",
				"CertificateRequestInfo struct, SignatureSchemes []SignatureScheme"));
		mapConst.get("crypto/tls").add(
				new ConstGoLangApiSignature("crypto/tls", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", " 49187", null));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "ECDSAWithP384AndSHA384", null, "SignatureScheme"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "PSSWithSHA384", null, "SignatureScheme"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305", " 52392", null));
		mapType.get("crypto/tls").add(new TypeGoLangApiSignature("crypto/tls", "CertificateRequestInfo struct"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "PKCS1WithSHA512", null, "SignatureScheme"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305", null, "uint16"));
		mapConst.get("crypto/tls").add(
				new ConstGoLangApiSignature("crypto/tls", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", " 49191", null));
		mapType.get("crypto/tls")
				.add(new TypeGoLangApiSignature("crypto/tls", "ClientHelloInfo struct, SupportedProtos []string"));
		mapType.get("crypto/tls").add(new TypeGoLangApiSignature("crypto/tls",
				"Config struct, GetClientCertificate func(*CertificateRequestInfo) (*Certificate, error)"));
		mapMethod.get("crypto/tls").add(new MethodGoLangApiSignature("crypto/tls", "*Conn", "CloseWrite",
				new String[] { "" }, new String[] { "error" }));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "ECDSAWithP256AndSHA256", null, "SignatureScheme"));
		mapConst.get("crypto/tls").add(
				new ConstGoLangApiSignature("crypto/tls", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", null, "uint16"));
		mapType.get("crypto/tls").add(new TypeGoLangApiSignature("crypto/tls", "SignatureScheme uint16"));
		mapConst.get("crypto/tls").add(
				new ConstGoLangApiSignature("crypto/tls", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", null, "uint16"));
		mapType.get("crypto/tls").add(
				new TypeGoLangApiSignature("crypto/tls", "ClientHelloInfo struct, SignatureSchemes []SignatureScheme"));
		mapType.get("crypto/tls").add(new TypeGoLangApiSignature("crypto/tls",
				"Config struct, VerifyPeerCertificate func([][]uint8, [][]*x509.Certificate) error"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "ECDSAWithP521AndSHA512", null, "SignatureScheme"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "PKCS1WithSHA1", null, "SignatureScheme"));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "PSSWithSHA384", " 2053", null));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "X25519", " 29", null));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "ECDSAWithP384AndSHA384", " 1283", null));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "PKCS1WithSHA384", " 1281", null));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "ECDSAWithP256AndSHA256", " 1027", null));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "PKCS1WithSHA384", null, "SignatureScheme"));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "PKCS1WithSHA256", " 1025", null));
		mapConst.get("crypto/tls").add(
				new ConstGoLangApiSignature("crypto/tls", "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305", " 52393", null));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "PKCS1WithSHA512", " 1537", null));
		mapType.get("crypto/tls").add(new TypeGoLangApiSignature("crypto/tls",
				"Config struct, GetConfigForClient func(*ClientHelloInfo) (*Config, error)"));
		mapType.get("crypto/tls")
				.add(new TypeGoLangApiSignature("crypto/tls", "Config struct, KeyLogWriter io.Writer"));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "PSSWithSHA256", " 2052", null));
		mapMethod.get("crypto/tls").add(new MethodGoLangApiSignature("crypto/tls", "*Config", "Clone",
				new String[] { "" }, new String[] { "*Config" }));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "X25519", null, "CurveID"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "TLS_RSA_WITH_AES_128_CBC_SHA256", " 60", null));
		mapType.get("crypto/tls")
				.add(new TypeGoLangApiSignature("crypto/tls", "ClientHelloInfo struct, SupportedVersions []uint16"));
		mapType.get("crypto/tls")
				.add(new TypeGoLangApiSignature("crypto/tls", "ClientHelloInfo struct, Conn net.Conn"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "PSSWithSHA256", null, "SignatureScheme"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "TLS_RSA_WITH_AES_128_CBC_SHA256", null, "uint16"));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "ECDSAWithP521AndSHA512", " 1539", null));
		mapConst.get("crypto/tls").add(new ConstGoLangApiSignature("crypto/tls", "PKCS1WithSHA1", " 513", null));
		mapConst.get("crypto/tls")
				.add(new ConstGoLangApiSignature("crypto/tls", "PKCS1WithSHA256", null, "SignatureScheme"));

		pkgs.add("database/sql/driver");
		mapConst.putIfAbsent("database/sql/driver", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("database/sql/driver", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("database/sql/driver", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("database/sql/driver", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("database/sql/driver", new HashSet<VarGoLangApiSignature>());

		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypePrecisionScale interface, Close() error"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"StmtQueryContext interface, QueryContext(context.Context, []NamedValue) (Rows, error)"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "QueryerContext interface { QueryContext }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypePrecisionScale interface { Close, ColumnTypePrecisionScale, Columns, Next }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsNextResultSet interface { Close, Columns, HasNextResultSet, Next, NextResultSet }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeNullable interface, Columns() []string"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"ConnPrepareContext interface, PrepareContext(context.Context, string) (Stmt, error)"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "ConnBeginTx interface { BeginTx }"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "ExecerContext interface { ExecContext }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeScanType interface, ColumnTypeScanType(int) reflect.Type"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeDatabaseTypeName interface { Close, ColumnTypeDatabaseTypeName, Columns, Next }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsNextResultSet interface, NextResultSet() error"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeNullable interface, ColumnTypeNullable(int) (bool, bool)"));
		mapType.get("database/sql/driver").add(
				new TypeGoLangApiSignature("database/sql/driver", "RowsColumnTypeScanType interface, Close() error"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypePrecisionScale interface, ColumnTypePrecisionScale(int) (int64, int64, bool)"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeScanType interface, Columns() []string"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypePrecisionScale interface, Columns() []string"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"ConnBeginTx interface, BeginTx(context.Context, TxOptions) (Tx, error)"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeScanType interface { Close, ColumnTypeScanType, Columns, Next }"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "NamedValue struct, Name string"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeDatabaseTypeName interface, ColumnTypeDatabaseTypeName(int) string"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeNullable interface { Close, ColumnTypeNullable, Columns, Next }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeDatabaseTypeName interface, Close() error"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "Pinger interface { Ping }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypePrecisionScale interface, Next([]Value) error"));
		mapType.get("database/sql/driver").add(
				new TypeGoLangApiSignature("database/sql/driver", "RowsNextResultSet interface, Next([]Value) error"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeScanType interface, Next([]Value) error"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "StmtQueryContext interface { QueryContext }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver", "NamedValue struct"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeDatabaseTypeName interface, Columns() []string"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeLength interface, Columns() []string"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeNullable interface, Next([]Value) error"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver", "TxOptions struct"));
		mapType.get("database/sql/driver").add(
				new TypeGoLangApiSignature("database/sql/driver", "RowsColumnTypeLength interface, Close() error"));
		mapType.get("database/sql/driver").add(
				new TypeGoLangApiSignature("database/sql/driver", "RowsColumnTypeNullable interface, Close() error"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"StmtExecContext interface, ExecContext(context.Context, []NamedValue) (Result, error)"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "TxOptions struct, ReadOnly bool"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver", "IsolationLevel int"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"QueryerContext interface, QueryContext(context.Context, string, []NamedValue) (Rows, error)"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeLength interface, ColumnTypeLength(int) (int64, bool)"));
		mapType.get("database/sql/driver").add(
				new TypeGoLangApiSignature("database/sql/driver", "RowsNextResultSet interface, Columns() []string"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeLength interface, Next([]Value) error"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"ExecerContext interface, ExecContext(context.Context, string, []NamedValue) (Result, error)"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "RowsNextResultSet interface, Close() error"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "TxOptions struct, Isolation IsolationLevel"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "NamedValue struct, Value Value"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "StmtExecContext interface { ExecContext }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeLength interface { Close, ColumnTypeLength, Columns, Next }"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsColumnTypeDatabaseTypeName interface, Next([]Value) error"));
		mapType.get("database/sql/driver").add(
				new TypeGoLangApiSignature("database/sql/driver", "ConnPrepareContext interface { PrepareContext }"));
		mapType.get("database/sql/driver")
				.add(new TypeGoLangApiSignature("database/sql/driver", "NamedValue struct, Ordinal int"));
		mapType.get("database/sql/driver").add(
				new TypeGoLangApiSignature("database/sql/driver", "Pinger interface, Ping(context.Context) error"));
		mapType.get("database/sql/driver").add(new TypeGoLangApiSignature("database/sql/driver",
				"RowsNextResultSet interface, HasNextResultSet() bool"));

		pkgs.add("expvar");
		mapConst.putIfAbsent("expvar", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("expvar", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("expvar", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("expvar", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("expvar", new HashSet<VarGoLangApiSignature>());

		mapMethod.get("expvar").add(new MethodGoLangApiSignature("expvar", "*String", "Value", new String[] { "" },
				new String[] { "string" }));
		mapFunc.get("expvar").add(
				new FuncGoLangApiSignature("expvar", "Handler", new String[] { "" }, new String[] { "http.Handler" }));
		mapMethod.get("expvar").add(
				new MethodGoLangApiSignature("expvar", "*Int", "Value", new String[] { "" }, new String[] { "int64" }));
		mapMethod.get("expvar").add(new MethodGoLangApiSignature("expvar", "*Float", "Value", new String[] { "" },
				new String[] { "float64" }));
		mapMethod.get("expvar").add(new MethodGoLangApiSignature("expvar", "Func", "Value", new String[] { "" },
				new String[] { "interface{}" }));

		pkgs.add("math/rand");
		mapConst.putIfAbsent("math/rand", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("math/rand", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("math/rand", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("math/rand", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("math/rand", new HashSet<VarGoLangApiSignature>());

		mapMethod.get("math/rand").add(new MethodGoLangApiSignature("math/rand", "*Rand", "Uint64", new String[] { "" },
				new String[] { "uint64" }));
		mapType.get("math/rand").add(new TypeGoLangApiSignature("math/rand", "Source64 interface, Int63() int64"));
		mapType.get("math/rand").add(new TypeGoLangApiSignature("math/rand", "Source64 interface, Seed(int64)"));
		mapFunc.get("math/rand")
				.add(new FuncGoLangApiSignature("math/rand", "Uint64", new String[] { "" }, new String[] { "uint64" }));
		mapType.get("math/rand")
				.add(new TypeGoLangApiSignature("math/rand", "Source64 interface { Int63, Seed, Uint64 }"));
		mapType.get("math/rand").add(new TypeGoLangApiSignature("math/rand", "Source64 interface, Uint64() uint64"));

		pkgs.add("syscall (linux-arm-cgo)");
		mapConst.putIfAbsent("syscall (linux-arm-cgo)", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("syscall (linux-arm-cgo)", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("syscall (linux-arm-cgo)", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("syscall (linux-arm-cgo)", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("syscall (linux-arm-cgo)", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("syscall (linux-arm-cgo)").add(new FuncGoLangApiSignature("syscall (linux-arm-cgo)",
				"TimevalToNsec", new String[] { "Timeval" }, new String[] { "int64" }));

		pkgs.add("sort, func SliceIsSorted(interface{}");
		mapConst.putIfAbsent("sort, func SliceIsSorted(interface{}", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("sort, func SliceIsSorted(interface{}", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("sort, func SliceIsSorted(interface{}", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("sort, func SliceIsSorted(interface{}", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("sort, func SliceIsSorted(interface{}", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("sort, func SliceIsSorted(interface{}").add(new FuncGoLangApiSignature("sort", "SliceIsSorted",
				new String[] { "interface{}", " func(int", " int" }, new String[] { "bool) bool" }));

		pkgs.add("reflect");
		mapConst.putIfAbsent("reflect", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("reflect", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("reflect", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("reflect", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("reflect", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("reflect").add(new FuncGoLangApiSignature("reflect", "Swapper", new String[] { "interface{}" },
				new String[] { "funcint", " int" }));

		pkgs.add("compress/gzip");
		mapConst.putIfAbsent("compress/gzip", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("compress/gzip", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("compress/gzip", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("compress/gzip", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("compress/gzip", new HashSet<VarGoLangApiSignature>());

		mapConst.get("compress/gzip").add(new ConstGoLangApiSignature("compress/gzip", "HuffmanOnly", " -2", null));
		mapConst.get("compress/gzip")
				.add(new ConstGoLangApiSignature("compress/gzip", "HuffmanOnly", null, "ideal-int"));

		pkgs.add("debug/pe");
		mapConst.putIfAbsent("debug/pe", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("debug/pe", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("debug/pe", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("debug/pe", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("debug/pe", new HashSet<VarGoLangApiSignature>());

		mapMethod.get("debug/pe").add(new MethodGoLangApiSignature("debug/pe", "StringTable", "String",
				new String[] { "uint32" }, new String[] { "string", " error" }));
		mapType.get("debug/pe").add(new TypeGoLangApiSignature("debug/pe", "Reloc struct"));
		mapType.get("debug/pe").add(new TypeGoLangApiSignature("debug/pe", "Section struct, Relocs []Reloc"));
		mapType.get("debug/pe").add(new TypeGoLangApiSignature("debug/pe", "StringTable []uint8"));
		mapType.get("debug/pe").add(new TypeGoLangApiSignature("debug/pe", "File struct, COFFSymbols []COFFSymbol"));
		mapType.get("debug/pe").add(new TypeGoLangApiSignature("debug/pe", "Reloc struct, VirtualAddress uint32"));
		mapMethod.get("debug/pe").add(new MethodGoLangApiSignature("debug/pe", "*COFFSymbol", "FullName",
				new String[] { "StringTable" }, new String[] { "string", " error" }));
		mapType.get("debug/pe").add(new TypeGoLangApiSignature("debug/pe", "Reloc struct, SymbolTableIndex uint32"));
		mapType.get("debug/pe").add(new TypeGoLangApiSignature("debug/pe", "File struct, StringTable StringTable"));
		mapType.get("debug/pe").add(new TypeGoLangApiSignature("debug/pe", "Reloc struct, Type uint16"));

		pkgs.add("crypto/x509");
		mapConst.putIfAbsent("crypto/x509", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("crypto/x509", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("crypto/x509", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("crypto/x509", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("crypto/x509", new HashSet<VarGoLangApiSignature>());

		mapConst.get("crypto/x509").add(new ConstGoLangApiSignature("crypto/x509", "NameMismatch", " 5", null));
		mapConst.get("crypto/x509").add(new ConstGoLangApiSignature("crypto/x509", "SHA256WithRSAPSS", " 13", null));
		mapConst.get("crypto/x509")
				.add(new ConstGoLangApiSignature("crypto/x509", "SHA512WithRSAPSS", null, "SignatureAlgorithm"));
		mapConst.get("crypto/x509")
				.add(new ConstGoLangApiSignature("crypto/x509", "NameMismatch", null, "InvalidReason"));
		mapConst.get("crypto/x509").add(new ConstGoLangApiSignature("crypto/x509", "SHA384WithRSAPSS", " 14", null));
		mapConst.get("crypto/x509")
				.add(new ConstGoLangApiSignature("crypto/x509", "SHA256WithRSAPSS", null, "SignatureAlgorithm"));
		mapConst.get("crypto/x509")
				.add(new ConstGoLangApiSignature("crypto/x509", "SHA384WithRSAPSS", null, "SignatureAlgorithm"));
		mapConst.get("crypto/x509").add(new ConstGoLangApiSignature("crypto/x509", "SHA512WithRSAPSS", " 15", null));
		mapType.get("crypto/x509")
				.add(new TypeGoLangApiSignature("crypto/x509", "UnknownAuthorityError struct, Cert *Certificate"));

		pkgs.add("sort, func SliceStable(interface{}");
		mapConst.putIfAbsent("sort, func SliceStable(interface{}", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("sort, func SliceStable(interface{}", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("sort, func SliceStable(interface{}", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("sort, func SliceStable(interface{}", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("sort, func SliceStable(interface{}", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("sort, func SliceStable(interface{}").add(new FuncGoLangApiSignature("sort", "SliceStable",
				new String[] { "interface{}", " func(int", " int" }, new String[] { "bool)" }));

		pkgs.add("encoding/base64");
		mapConst.putIfAbsent("encoding/base64", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("encoding/base64", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("encoding/base64", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("encoding/base64", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("encoding/base64", new HashSet<VarGoLangApiSignature>());

		mapMethod.get("encoding/base64").add(new MethodGoLangApiSignature("encoding/base64", "Encoding", "Strict",
				new String[] { "" }, new String[] { "*Encoding" }));

		pkgs.add("net");
		mapConst.putIfAbsent("net", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("net", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("net", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("net", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("net", new HashSet<VarGoLangApiSignature>());

		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Resolver", "LookupAddr",
				new String[] { "context.Context", " string" }, new String[] { "[]string", " error" }));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Resolver", "LookupMX",
				new String[] { "context.Context", " string" }, new String[] { "[]*MX", " error" }));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Resolver", "LookupNS",
				new String[] { "context.Context", " string" }, new String[] { "[]*NS", " error" }));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*UnixListener", "SetUnlinkOnClose",
				new String[] { "bool" }, new String[] { "" }));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Resolver", "LookupHost",
				new String[] { "context.Context", " string" }, new String[] { "[]string", " error" }));
		mapType.get("net").add(new TypeGoLangApiSignature("net", "Resolver struct"));
		mapVar.get("net").add(new VarGoLangApiSignature("net", "DefaultResolver", "*Resolver"));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Resolver", "LookupCNAME",
				new String[] { "context.Context", " string" }, new String[] { "string", " error" }));
		mapType.get("net").add(new TypeGoLangApiSignature("net", "Buffers [][]uint8"));
		mapType.get("net").add(new TypeGoLangApiSignature("net", "Dialer struct, Resolver *Resolver"));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Buffers", "Read", new String[] { "[]uint8" },
				new String[] { "int", " error" }));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Buffers", "WriteTo",
				new String[] { "io.Writer" }, new String[] { "int64", " error" }));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Resolver", "LookupPort",
				new String[] { "context.Context", " string", " string" }, new String[] { "int", " error" }));
		mapMethod.get("net")
				.add(new MethodGoLangApiSignature("net", "*Resolver", "LookupSRV",
						new String[] { "context.Context", " string", " string", " string" },
						new String[] { "string", " []*SRV", " error" }));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Resolver", "LookupIPAddr",
				new String[] { "context.Context", " string" }, new String[] { "[]IPAddr", " error" }));
		mapType.get("net").add(new TypeGoLangApiSignature("net", "Resolver struct, PreferGo bool"));
		mapMethod.get("net").add(new MethodGoLangApiSignature("net", "*Resolver", "LookupTXT",
				new String[] { "context.Context", " string" }, new String[] { "[]string", " error" }));

		pkgs.add("net/http/httptrace");
		mapConst.putIfAbsent("net/http/httptrace", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("net/http/httptrace", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("net/http/httptrace", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("net/http/httptrace", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("net/http/httptrace", new HashSet<VarGoLangApiSignature>());

		mapType.get("net/http/httptrace").add(new TypeGoLangApiSignature("net/http/httptrace",
				"ClientTrace struct, TLSHandshakeDone func(tls.ConnectionState, error)"));
		mapType.get("net/http/httptrace")
				.add(new TypeGoLangApiSignature("net/http/httptrace", "ClientTrace struct, TLSHandshakeStart func()"));

		pkgs.add("syscall (windows-386)");
		mapConst.putIfAbsent("syscall (windows-386)", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("syscall (windows-386)", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("syscall (windows-386)", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("syscall (windows-386)", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("syscall (windows-386)", new HashSet<VarGoLangApiSignature>());

		mapConst.get("syscall (windows-386)")
				.add(new ConstGoLangApiSignature("syscall (windows-386)", "ERROR_DIR_NOT_EMPTY", null, "Errno"));
		mapConst.get("syscall (windows-386)")
				.add(new ConstGoLangApiSignature("syscall (windows-386)", "ERROR_DIR_NOT_EMPTY", " 145", null));

		pkgs.add("os");
		mapConst.putIfAbsent("os", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("os", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("os", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("os", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("os", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("os").add(new FuncGoLangApiSignature("os", "Executable", new String[] { "" },
				new String[] { "string", " error" }));
		mapVar.get("os").add(new VarGoLangApiSignature("os", "ErrClosed", "error"));

		pkgs.add("compress/zlib");
		mapConst.putIfAbsent("compress/zlib", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("compress/zlib", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("compress/zlib", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("compress/zlib", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("compress/zlib", new HashSet<VarGoLangApiSignature>());

		mapConst.get("compress/zlib").add(new ConstGoLangApiSignature("compress/zlib", "HuffmanOnly", " -2", null));
		mapConst.get("compress/zlib")
				.add(new ConstGoLangApiSignature("compress/zlib", "HuffmanOnly", null, "ideal-int"));

		pkgs.add("net/http/httputil");
		mapConst.putIfAbsent("net/http/httputil", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("net/http/httputil", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("net/http/httputil", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("net/http/httputil", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("net/http/httputil", new HashSet<VarGoLangApiSignature>());

		mapType.get("net/http/httputil").add(new TypeGoLangApiSignature("net/http/httputil",
				"ReverseProxy struct, ModifyResponse func(*http.Response) error"));

		pkgs.add("math/big");
		mapConst.putIfAbsent("math/big", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("math/big", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("math/big", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("math/big", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("math/big", new HashSet<VarGoLangApiSignature>());

		mapMethod.get("math/big").add(new MethodGoLangApiSignature("math/big", "*Float", "Scan",
				new String[] { "fmt.ScanState", " int32" }, new String[] { "error" }));
		mapMethod.get("math/big").add(new MethodGoLangApiSignature("math/big", "*Int", "Sqrt", new String[] { "*Int" },
				new String[] { "*Int" }));

		pkgs.add("syscall (openbsd-amd64-cgo)");
		mapConst.putIfAbsent("syscall (openbsd-amd64-cgo)", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("syscall (openbsd-amd64-cgo)", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("syscall (openbsd-amd64-cgo)", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("syscall (openbsd-amd64-cgo)", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("syscall (openbsd-amd64-cgo)", new HashSet<VarGoLangApiSignature>());

		mapConst.get("syscall (openbsd-amd64-cgo)")
				.add(new ConstGoLangApiSignature("syscall (openbsd-amd64-cgo)", "SYS_KILL", " 122", null));

		pkgs.add("go/doc");
		mapConst.putIfAbsent("go/doc", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("go/doc", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("go/doc", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("go/doc", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("go/doc", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("go/doc").add(new FuncGoLangApiSignature("go/doc", "IsPredeclared", new String[] { "string" },
				new String[] { "bool" }));

		pkgs.add("testing");
		mapConst.putIfAbsent("testing", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("testing", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("testing", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("testing", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("testing", new HashSet<VarGoLangApiSignature>());

		mapType.get("testing").add(new TypeGoLangApiSignature("testing", "TB interface, Name() string"));
		mapMethod.get("testing").add(
				new MethodGoLangApiSignature("testing", "*B", "Name", new String[] { "" }, new String[] { "string" }));
		mapMethod.get("testing").add(
				new MethodGoLangApiSignature("testing", "*T", "Name", new String[] { "" }, new String[] { "string" }));
		mapFunc.get("testing")
				.add(new FuncGoLangApiSignature("testing", "MainStart",
						new String[] { "testDeps", " []InternalTest", " []InternalBenchmark", " []InternalExample" },
						new String[] { "*M" }));
		mapFunc.get("testing").add(
				new FuncGoLangApiSignature("testing", "CoverMode", new String[] { "" }, new String[] { "string" }));

		pkgs.add("syscall (openbsd-386-cgo)");
		mapConst.putIfAbsent("syscall (openbsd-386-cgo)", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("syscall (openbsd-386-cgo)", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("syscall (openbsd-386-cgo)", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("syscall (openbsd-386-cgo)", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("syscall (openbsd-386-cgo)", new HashSet<VarGoLangApiSignature>());

		mapConst.get("syscall (openbsd-386-cgo)")
				.add(new ConstGoLangApiSignature("syscall (openbsd-386-cgo)", "SYS_KILL", " 122", null));

		pkgs.add("go/types");
		mapConst.putIfAbsent("go/types", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("go/types", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("go/types", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("go/types", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("go/types", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("go/types").add(
				new FuncGoLangApiSignature("go/types", "Default", new String[] { "Type" }, new String[] { "Type" }));
		mapFunc.get("go/types").add(new FuncGoLangApiSignature("go/types", "IdenticalIgnoreTags",
				new String[] { "Type", " Type" }, new String[] { "bool" }));

		pkgs.add("runtime");
		mapConst.putIfAbsent("runtime", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("runtime", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("runtime", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("runtime", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("runtime", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("runtime").add(new FuncGoLangApiSignature("runtime", "MutexProfile",
				new String[] { "[]BlockProfileRecord" }, new String[] { "int", " bool" }));
		mapType.get("runtime").add(new TypeGoLangApiSignature("runtime", "MemStats struct, NumForcedGC uint32"));
		mapFunc.get("runtime").add(new FuncGoLangApiSignature("runtime", "SetMutexProfileFraction",
				new String[] { "int" }, new String[] { "int" }));

		pkgs.add("net/http");
		mapConst.putIfAbsent("net/http", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("net/http", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("net/http", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("net/http", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("net/http", new HashSet<VarGoLangApiSignature>());

		mapType.get("net/http").add(new TypeGoLangApiSignature("net/http", "Server struct, IdleTimeout time.Duration"));
		mapType.get("net/http")
				.add(new TypeGoLangApiSignature("net/http", "Pusher interface, Push(string, *PushOptions) error"));
		mapType.get("net/http")
				.add(new TypeGoLangApiSignature("net/http", "Server struct, ReadHeaderTimeout time.Duration"));
		mapType.get("net/http")
				.add(new TypeGoLangApiSignature("net/http", "Transport struct, ProxyConnectHeader Header"));
		mapMethod.get("net/http").add(new MethodGoLangApiSignature("net/http", "*Server", "Shutdown",
				new String[] { "context.Context" }, new String[] { "error" }));
		mapType.get("net/http").add(new TypeGoLangApiSignature("net/http", "PushOptions struct, Method string"));
		mapVar.get("net/http").add(new VarGoLangApiSignature("net/http", "ErrServerClosed", "error"));
		mapConst.get("net/http").add(new ConstGoLangApiSignature("net/http", "TrailerPrefix", null, "ideal-string"));
		mapType.get("net/http").add(new TypeGoLangApiSignature("net/http", "PushOptions struct"));
		mapType.get("net/http").add(new TypeGoLangApiSignature("net/http", "Pusher interface { Push }"));
		mapConst.get("net/http").add(new ConstGoLangApiSignature("net/http", "TrailerPrefix", " \"Trailer:\"", null));
		mapType.get("net/http")
				.add(new TypeGoLangApiSignature("net/http", "Request struct, GetBody func() (io.ReadCloser, error)"));
		mapVar.get("net/http").add(new VarGoLangApiSignature("net/http", "ErrAbortHandler", "error"));
		mapType.get("net/http").add(new TypeGoLangApiSignature("net/http", "PushOptions struct, Header Header"));
		mapVar.get("net/http").add(new VarGoLangApiSignature("net/http", "NoBody", "noBody"));
		mapMethod.get("net/http").add(new MethodGoLangApiSignature("net/http", "*Server", "Close", new String[] { "" },
				new String[] { "error" }));

		pkgs.add("syscall (openbsd-amd64)");
		mapConst.putIfAbsent("syscall (openbsd-amd64)", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("syscall (openbsd-amd64)", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("syscall (openbsd-amd64)", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("syscall (openbsd-amd64)", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("syscall (openbsd-amd64)", new HashSet<VarGoLangApiSignature>());

		mapConst.get("syscall (openbsd-amd64)")
				.add(new ConstGoLangApiSignature("syscall (openbsd-amd64)", "SYS_KILL", " 122", null));

		pkgs.add("database/sql");
		mapConst.putIfAbsent("database/sql", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("database/sql", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("database/sql", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("database/sql", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("database/sql", new HashSet<VarGoLangApiSignature>());

		mapType.get("database/sql")
				.add(new TypeGoLangApiSignature("database/sql", "NamedArg struct, Value interface{}"));
		mapConst.get("database/sql").add(new ConstGoLangApiSignature("database/sql", "LevelSnapshot", " 5", null));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Tx", "PrepareContext",
				new String[] { "context.Context", " string" }, new String[] { "*Stmt", " error" }));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelWriteCommitted", " 3", null));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*DB", "ExecContext",
				new String[] { "context.Context", " string", " ...interface{}" }, new String[] { "Result", " error" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Tx", "StmtContext",
				new String[] { "context.Context", " *Stmt" }, new String[] { "*Stmt" }));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelWriteCommitted", null, "IsolationLevel"));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelReadUncommitted", null, "IsolationLevel"));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelLinearizable", null, "IsolationLevel"));
		mapFunc.get("database/sql").add(new FuncGoLangApiSignature("database/sql", "Named",
				new String[] { "string", " interface{}" }, new String[] { "NamedArg" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*ColumnType",
				"DatabaseTypeName", new String[] { "" }, new String[] { "string" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*DB", "BeginTx",
				new String[] { "context.Context", " *TxOptions" }, new String[] { "*Tx", " error" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*DB", "QueryRowContext",
				new String[] { "context.Context", " string", " ...interface{}" }, new String[] { "*Row" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Stmt", "QueryContext",
				new String[] { "context.Context", " ...interface{}" }, new String[] { "*Rows", " error" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*ColumnType", "ScanType",
				new String[] { "" }, new String[] { "reflect.Type" }));
		mapType.get("database/sql").add(new TypeGoLangApiSignature("database/sql", "NamedArg struct, Name string"));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*ColumnType", "Length",
				new String[] { "" }, new String[] { "int64", " bool" }));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelRepeatableRead", " 4", null));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelRepeatableRead", null, "IsolationLevel"));
		mapType.get("database/sql").add(new TypeGoLangApiSignature("database/sql", "ColumnType struct"));
		mapConst.get("database/sql").add(new ConstGoLangApiSignature("database/sql", "LevelLinearizable", " 7", null));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelSerializable", null, "IsolationLevel"));
		mapType.get("database/sql")
				.add(new TypeGoLangApiSignature("database/sql", "TxOptions struct, Isolation IsolationLevel"));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Rows", "NextResultSet",
				new String[] { "" }, new String[] { "bool" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*ColumnType", "Nullable",
				new String[] { "" }, new String[] { "bool", " bool" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Rows", "ColumnTypes",
				new String[] { "" }, new String[] { "[]*ColumnType", " error" }));
		mapType.get("database/sql").add(new TypeGoLangApiSignature("database/sql", "NamedArg struct"));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*DB", "QueryContext",
				new String[] { "context.Context", " string", " ...interface{}" }, new String[] { "*Rows", " error" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*DB", "PrepareContext",
				new String[] { "context.Context", " string" }, new String[] { "*Stmt", " error" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Tx", "QueryRowContext",
				new String[] { "context.Context", " string", " ...interface{}" }, new String[] { "*Row" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*ColumnType", "DecimalSize",
				new String[] { "" }, new String[] { "int64", " int64", " bool" }));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelDefault", null, "IsolationLevel"));
		mapType.get("database/sql").add(new TypeGoLangApiSignature("database/sql", "IsolationLevel int"));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Stmt", "QueryRowContext",
				new String[] { "context.Context", " ...interface{}" }, new String[] { "*Row" }));
		mapConst.get("database/sql").add(new ConstGoLangApiSignature("database/sql", "LevelSerializable", " 6", null));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelReadCommitted", null, "IsolationLevel"));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*DB", "PingContext",
				new String[] { "context.Context" }, new String[] { "error" }));
		mapConst.get("database/sql").add(new ConstGoLangApiSignature("database/sql", "LevelDefault", " 0", null));
		mapConst.get("database/sql").add(new ConstGoLangApiSignature("database/sql", "LevelReadCommitted", " 2", null));
		mapType.get("database/sql").add(new TypeGoLangApiSignature("database/sql", "TxOptions struct, ReadOnly bool"));
		mapType.get("database/sql").add(new TypeGoLangApiSignature("database/sql", "TxOptions struct"));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelReadUncommitted", " 1", null));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Stmt", "ExecContext",
				new String[] { "context.Context", " ...interface{}" }, new String[] { "Result", " error" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Tx", "QueryContext",
				new String[] { "context.Context", " string", " ...interface{}" }, new String[] { "*Rows", " error" }));
		mapConst.get("database/sql")
				.add(new ConstGoLangApiSignature("database/sql", "LevelSnapshot", null, "IsolationLevel"));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*ColumnType", "Name",
				new String[] { "" }, new String[] { "string" }));
		mapMethod.get("database/sql").add(new MethodGoLangApiSignature("database/sql", "*Tx", "ExecContext",
				new String[] { "context.Context", " string", " ...interface{}" }, new String[] { "Result", " error" }));

		pkgs.add("syscall (linux-arm)");
		mapConst.putIfAbsent("syscall (linux-arm)", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("syscall (linux-arm)", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("syscall (linux-arm)", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("syscall (linux-arm)", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("syscall (linux-arm)", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("syscall (linux-arm)").add(new FuncGoLangApiSignature("syscall (linux-arm)", "TimevalToNsec",
				new String[] { "Timeval" }, new String[] { "int64" }));

		pkgs.add("sort, func Slice(interface{}");
		mapConst.putIfAbsent("sort, func Slice(interface{}", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("sort, func Slice(interface{}", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("sort, func Slice(interface{}", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("sort, func Slice(interface{}", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("sort, func Slice(interface{}", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("sort, func Slice(interface{}").add(new FuncGoLangApiSignature("sort", "Slice",
				new String[] { "interface{}", " func(int", " int" }, new String[] { "bool)" }));

		pkgs.add("syscall (openbsd-386)");
		mapConst.putIfAbsent("syscall (openbsd-386)", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("syscall (openbsd-386)", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("syscall (openbsd-386)", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("syscall (openbsd-386)", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("syscall (openbsd-386)", new HashSet<VarGoLangApiSignature>());

		mapConst.get("syscall (openbsd-386)")
				.add(new ConstGoLangApiSignature("syscall (openbsd-386)", "SYS_KILL", " 122", null));

		pkgs.add("plugin");
		mapConst.putIfAbsent("plugin", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("plugin", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("plugin", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("plugin", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("plugin", new HashSet<VarGoLangApiSignature>());

		mapMethod.get("plugin").add(new MethodGoLangApiSignature("plugin", "*Plugin", "Lookup",
				new String[] { "string" }, new String[] { "Symbol", " error" }));
		mapFunc.get("plugin").add(new FuncGoLangApiSignature("plugin", "Open", new String[] { "string" },
				new String[] { "*Plugin", " error" }));
		mapType.get("plugin").add(new TypeGoLangApiSignature("plugin", "Symbol interface {}"));
		mapType.get("plugin").add(new TypeGoLangApiSignature("plugin", "Plugin struct"));

		pkgs.add("encoding/json");
		mapConst.putIfAbsent("encoding/json", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("encoding/json", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("encoding/json", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("encoding/json", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("encoding/json", new HashSet<VarGoLangApiSignature>());

		mapType.get("encoding/json")
				.add(new TypeGoLangApiSignature("encoding/json", "UnmarshalTypeError struct, Struct string"));
		mapType.get("encoding/json")
				.add(new TypeGoLangApiSignature("encoding/json", "UnmarshalTypeError struct, Field string"));
		mapMethod.get("encoding/json").add(new MethodGoLangApiSignature("encoding/json", "RawMessage", "MarshalJSON",
				new String[] { "" }, new String[] { "[]uint8", " error" }));

		pkgs.add("net/mail");
		mapConst.putIfAbsent("net/mail", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("net/mail", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("net/mail", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("net/mail", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("net/mail", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("net/mail").add(new FuncGoLangApiSignature("net/mail", "ParseDate", new String[] { "string" },
				new String[] { "time.Time", " error" }));

		pkgs.add("time");
		mapConst.putIfAbsent("time", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("time", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("time", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("time", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("time", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("time")
				.add(new FuncGoLangApiSignature("time", "Until", new String[] { "Time" }, new String[] { "Duration" }));

		pkgs.add("net/url");
		mapConst.putIfAbsent("net/url", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("net/url", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("net/url", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("net/url", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("net/url", new HashSet<VarGoLangApiSignature>());

		mapFunc.get("net/url").add(new FuncGoLangApiSignature("net/url", "PathEscape", new String[] { "string" },
				new String[] { "string" }));
		mapMethod.get("net/url").add(new MethodGoLangApiSignature("net/url", "*URL", "MarshalBinary",
				new String[] { "" }, new String[] { "[]uint8", " error" }));
		mapFunc.get("net/url").add(new FuncGoLangApiSignature("net/url", "PathUnescape", new String[] { "string" },
				new String[] { "string", " error" }));
		mapMethod.get("net/url").add(new MethodGoLangApiSignature("net/url", "*URL", "Hostname", new String[] { "" },
				new String[] { "string" }));
		mapMethod.get("net/url").add(new MethodGoLangApiSignature("net/url", "*URL", "Port", new String[] { "" },
				new String[] { "string" }));
		mapMethod.get("net/url").add(new MethodGoLangApiSignature("net/url", "*URL", "UnmarshalBinary",
				new String[] { "[]uint8" }, new String[] { "error" }));

		pkgs.add("syscall (windows-amd64)");
		mapConst.putIfAbsent("syscall (windows-amd64)", new HashSet<ConstGoLangApiSignature>());
		mapFunc.putIfAbsent("syscall (windows-amd64)", new HashSet<FuncGoLangApiSignature>());
		mapMethod.putIfAbsent("syscall (windows-amd64)", new HashSet<MethodGoLangApiSignature>());
		mapType.putIfAbsent("syscall (windows-amd64)", new HashSet<TypeGoLangApiSignature>());
		mapVar.putIfAbsent("syscall (windows-amd64)", new HashSet<VarGoLangApiSignature>());

		mapConst.get("syscall (windows-amd64)")
				.add(new ConstGoLangApiSignature("syscall (windows-amd64)", "ERROR_DIR_NOT_EMPTY", " 145", null));
		mapConst.get("syscall (windows-amd64)")
				.add(new ConstGoLangApiSignature("syscall (windows-amd64)", "ERROR_DIR_NOT_EMPTY", null, "Errno"));

	}

}